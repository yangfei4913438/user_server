## 系统设计

一个相对完善的用户管理系统。包含了消息队列、缓存、数据库、双token jwt 等内容。

其中，权限的修改，加入了乐观锁机制。这里只是用于乐观锁的技术演示（不是说这里真的需要乐观锁），也就是查询后不加锁，更新前比对记录更新时间。悲观锁就是查询后上锁，逻辑类似就不重复演示了。

正常的业务场景下，用户，角色，权限的操作，不会涉及高并发，不需要锁机制处理。锁机制主要出现在业务场景，因为业务场景面向的是不特定多数人群，而权限操作面向的是极个别的有限人群（尤其是类似本系统设计的单点登陆机制）。

任何一个技术，都是要用在合适的地方，不要把你会的一种技术，生搬硬套到所有地方。一定要灵活运用，无论什么时候，都只有最合适的技术，没有最好的技术。

### 功能设计目标：

#### 用户管理
- [x] 用户注册：提供多种注册API（手机号和邮箱原理类似，因为成本问题，这里就不实现了）
  - [x] 邮箱 + 密码注册
  - [x] 用户名 + 密码注册
- [x] 用户认证：提供登录API，根据用户提供的认证信息生成JWT。
  - [x] jwt: 
    - [x] 一个用户在有效时间内，只会生效一个访问token。
    - [x] 双token认证，访问token有效期12小时，刷新token有效期7天。
    - [x] 有单独的刷新接口，更新token
  - [x] 登陆认证方式
    - [x] 邮箱+验证码
    - [x] 邮箱+密码
    - [x] 用户名+密码
- [x] 用户列表获取
- [x] 用户信息获取
- [x] 用户资料更新
- [x] 用户注销
  - [x] 注销账号功能，软删除。
  - [x] 注销后 30 天内，用户可以继续登录，登录自动解除注销操作。
  - [x] 30 天内未登录，定时器执行真实的账号删除。
- [x] 用户操作审计
  - [x] 账号注册成功
  - [x] 资料变更成功
  - [x] 注销成功
  - [x] 真实删除成功

#### 权限管理
> 这边没有加入具体的业务逻辑，可以根据需要再做相应的调整。
- [x] 权限分类：浏览、创建、编辑、删除
- [x] 角色分类：管理员、编辑、会员、游客

### 技术栈
- Node.js with TypeScript：使用TypeScript编写Node.js应用，利用其静态类型检查提高代码质量。
- NestJS：利用NestJS的模块化、依赖注入和中间件功能，构建结构清晰的应用。
- MySQL：使用MySQL存储数据
- RabbitMQ：配置RabbitMQ用于处理邮件发送、审计日志记录等异步任务。
- Prisma：通过Prisma Migrate管理数据库迁移，确保开发和生产环境的一致性。
- Redis：配置Redis缓存用户信息和权限等数据，设置合适的缓存策略和过期时间。
- JWT：使用JWT进行用户认证，确保每个请求都携带有效的JWT（注册认证相关接口除外）

### 安全性考虑
- 数据加密：使用 argon2 等算法对用户密码进行哈希存储。argon2的安全系数相比于常见的哈希算法，要高出很多。Argon2有三个变种：Argon2i, Argon2d, and Argon2id：
  - Argon2d是比较快的，被用于数据依赖的内存访问，这使得它对GPU破解攻击具有很高的抵抗力，适用于不受侧信道攻击威胁的应用程序（如加密货币）
  - Argon2i使用独立于数据的内存访问，这是密码散列和基于密码的密钥派生的首选方法，但速度较慢，因为它会在内存中进行更多的传递，以防止受到折衷攻击。
  - Argon2id是Argon2i和Argon2d的混合体，使用依赖于数据和独立于数据的内存访问的组合，这使Argon2i能够抵抗侧通道缓存计时攻击，并使Argon2d能够抵抗GPU破解攻击。
- 访问控制：使用NestJS的Guard功能实现基于角色的访问控制。
- 审计日志: 记录所有的增删改操作, 方便追溯操作记录。

### 开发

- 同步数据库

  `npm run prisma:md init`

- 生成客户端

  `npm run prisma:gen`

- 查看数据库开发文档

  `npm run prisma:doc`

### 普通运行

#### 1、安装依赖

  ```bash
  npm install
  ```

#### 2、配置环境变量

  > 使用本地的环境变量文件模板 `env.example` 改一个 .env 文件

#### 3、启动服务

  ```bash
  npm run start:dev
  ```

#### 4、查看swagger接口文档

  ```bash
  http://127.0.0.1:3006
  ```

### docker 运行

  > 因为只是演示，所以这里的步骤，只针对本地docker环境，不是正式服务器上的操作步骤. 这个需要先安装本地的 docker 运行环境。

#### 1、创建环境变量文件 .env
  > 根据实际的本地服务配置，MySQL 要先创建一个数据库
  > 使用本地的环境变量文件模板 `env.example` 改一个 .env 文件. 根据实际情况填。
  > 注意：ip要写局域网ip, 不要写成127.0.0.1

#### 2、在项目的根目录下执行, 构建docker镜像
  
  ```shell
  docker build -t user_server:first .
  ```

#### 3、运行镜像

  ```shell
  docker run --name user_server_container -p 3006:3006 -d --restart=always user_server:first
  ```

#### 4、查看swagger接口文档

  ```bash
  http://127.0.0.1:3006
  ```